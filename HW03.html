<!DOCTYPE html>
<html>
<head>
<style>
#container {
  width: 40vw;
  height: 30vw;
  float: left;
  background-color: yellow;
  margin-left: 2vw;
}

#bigContainer{
	width: 54vw;
	float: right;
}

#container2 {
  width: 16vw;
  height: 12vw;
  float: left;
  background-color: red;
  margin-top:1vw;
  margin-right:1vw;
}

#container3 {
  width: 16vw;
  height: 12vw;
  float: left;
  background-color: red;
  margin-top:1vw;
  margin-right:1vw;
}

#container4 {
  width: 16vw;
  height: 12vw;
  float: left;
  background-color: red;
  margin-top:1vw;
  margin-right:1vw;
}

p {
  margin: 10px;
  text-align: justify;
}

</style>
</head>
<body>
<h1 style="font-size:3em; text-align:center; margin:15px">
試作型&nbsp&nbsp&nbsp&nbsp<s>柚子社</s>&nbsp&nbsp千恋＊万花&nbsp&nbsp&nbsp&nbsp角色介紹館
</h1>
<hr>
<div id="container">
  <!--canvas id='mycanvas'></canvas-->
</div>

<div id="bigContainer">

<button id="butPower" style="width:40vw">Power Button</button>
<br><button id="butYL" style="width:15vw">YardLight Button</button>
<input type=range min=0.1 max=1 step=0.1 id='YLBrightness' style="width:15vw"> Brightness
<br><button id="butLamp" style="width:15vw">Lamp Button</button>
<input type=range min=0.1 max=0.7 step=0.1 id='lampBrightness' style="width:15vw"> Brightness
<br><button id="defaultCam" style="width:20vw">Default Camera</button><button id="switchCam" style="width:20vw">Camera Switch</button>

<div id="container2">
  <!--canvas id='mycanvas'></canvas-->
</div>

<div id="container3">
  <!--canvas id='mycanvas'></canvas-->
</div>

<div id="container4">
  <!--canvas id='mycanvas'></canvas-->
</div>

<div style="width:40vw" style="margin-right:5vw">
<div style="font-size:24px"> 角色說明: </div>
<div id="pictureInfo" style="font-size:16px">請點選左側畫面上的圖片！</div>
<div>

</div>

<!--
<p>
  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur quam lectus, porta eget tincidunt eget, auctor eget lorem. Cras sed est eu tellus consequat semper a ac dolor. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Maecenas feugiat
  luctus augue sed pellentesque. In laoreet tincidunt lacinia. In pellentesque egestas enim ut auctor. Mauris et urna at est varius faucibus quis at sapien. Nam hendrerit velit at bibendum fringilla. Sed ut dignissim dui, eget sagittis est. Pellentesque
  varius nibh ut nunc condimentum viverra. Fusce erat felis, laoreet vitae ex sit amet, venenatis lobortis nibh. Suspendisse lectus massa, malesuada vel ullamcorper sed, iaculis eu dolor. Donec accumsan diam non dolor aliquet, a cursus arcu hendrerit.
  Quisque accumsan sed quam at dictum.
</p>
<br>

<p>
  Nullam finibus felis et varius mollis. Donec sapien tellus, lacinia sit amet orci non, posuere laoreet nunc. Vivamus gravida turpis est, vulputate sagittis leo facilisis in. Sed aliquet ornare gravida. Nullam eget velit et lacus lacinia eleifend quis
  in metus. Vestibulum nec congue libero. Duis eu quam eu sem fermentum dapibus et vel ex. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae;
</p>
<hr>
<p>
  Vivamus et leo non turpis varius blandit. Aliquam sed metus ac nisl elementum fermentum et suscipit mauris. Curabitur nulla justo, aliquam at arcu nec, ullamcorper rutrum massa. Nam malesuada massa lorem, laoreet consectetur tortor fringilla quis. Ut
  in lacinia diam, ut elementum libero. Quisque tempor libero eget felis malesuada malesuada. In efficitur, ipsum id lacinia fermentum, tortor enim rhoncus ipsum, ac lobortis magna neque et neque. Class aptent taciti sociosqu ad litora torquent per conubia
  nostra, per inceptos himenaeos. Cras est dolor, condimentum tincidunt molestie at, fringilla quis velit.
</p>
-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/84/three.min.js"></script>
<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
<script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5/dat.gui.min.js"></script>
<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>

<script>

var scene, renderer, rederer2, rederer3, renderer4, camera, camera2, camera3, camera4;
var cameraOfPic;
var ruler = 0.2;
var lamp = [];
var yardLight = [];
var pointLightHelper = [];
var butPower = true;
var YLBrightness = 0.5;
var butYL = true;
var lampBrightness = 1.5;
var butLamp = true;
var angle = 0;
var sign = 1;
var cameras = [];
var counter = 0;
var camCase = [];
var angles = [];
var anglesCheck = [];
var signs = [];
var mouse = new THREE.Vector2();
var raycaster = new THREE.Raycaster();
var pickables = [];
var camerasOfPic = [];
var pictureInfos = [
"朝武 芳乃 （ともたけ よしの）　CV：遥そら\n穂織にある神社の巫女姫様。\n主人公が神刀をへし折ったことで、土地の掟に従ってムリヤリ婚約相手にされてしまう。\n生真面目な性格で若干クールに見られがちだが、実際は冷たい人間ではない。\n\n喜怒哀楽がわりとハッキリしていて、精神的には子供っぽい部分が多々ある。\n冷静沈着に振る舞おうとするものの、簡単なミスも多くて意外とヌケている。\n「～～～……とにかく、結婚なんてしませんから。 お父さんが勝手に言っているだけですから」\n",
"ムラサメ　CV：佐藤みかん\n神刀 “叢雨丸” に宿る魂のような存在。\n子供っぽい一面と、大人っぽい一面を併せ持っている。\n基本的には見た目通りの子供らしい性格で、元気で明るい女の子。\n数百年に渡り存在しているが、普通の人間には姿を見ることもできない。\n\n実は怖がりで、幽霊などが苦手。\n「吾輩の名はムラサメ。 この“叢雨丸”の管理者であり、神力（しんりき）を司る者である」"
];
var infoText;

class NewLamp {
  constructor(size, color, lightColor, lightPow) {
    this.box = new THREE.Mesh(new THREE.BoxGeometry(1 * size, 1 * size, 1 * size), new THREE.MeshPhongMaterial({
      color: color
    }));

    var tower = new THREE.Mesh(new THREE.CylinderGeometry(2 * size, 4 * size, 10 * size, 32, false, 0), new THREE.MeshPhongMaterial({
      color: color,
      side: THREE.DoubleSide
    }));
    this.box.add(tower);
    tower.castShadow = true; //default is false
    tower.receiveShadow = true; //default
    tower.position.y = -5 * size;

    var top = new THREE.Mesh(new THREE.CylinderGeometry(2 * size, 2 * size, 1 * size, 32), new THREE.MeshPhongMaterial({
      color: color,
      side: THREE.DoubleSide
    }));
    top.castShadow = true; //default is false
    top.receiveShadow = false; //default
    this.box.add(top);

    var bulb = new THREE.Mesh(new THREE.SphereGeometry(1 * size, 32, 32), new THREE.MeshPhongMaterial({
      color: 0x555555,
      opacity: 0.3,
      transparent: true,
      side: THREE.DoubleSide
    }));
    this.box.add(bulb);
    bulb.position.y = -2 * size;

    this.light = new THREE.PointLight(lightColor, lightPow, 0, 2);
    this.light.castShadow = true;
    this.box.add(this.light);
    this.light.position.y = -2 * size;

    scene.add(this.box);
  }
}

$("#defaultCam").click(function() {
  counter = 0;
  camera = cameras[counter];
});

$("#switchCam").click(function() {
  counter++;
  if (counter >= cameras.length)
    counter = 0;
  camera = cameras[counter];
});

class NewCamera {
  constructor() {
    this.sCam = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
    //cameras.push(sCam);

    this.cameraObj = new THREE.Object3D();
    //this.cameraObj.add(new THREE.AxisHelper(40))
    this.cameraBody = new THREE.Mesh(new THREE.BoxGeometry(5 * ruler, 5 * ruler, 10 * ruler), new THREE.MeshPhongMaterial({
      color: 0x555555
    }));
    this.cameraBody.castShadow = true; //default is false
    this.cameraBody.receiveShadow = true; //default
    this.lens = new THREE.Mesh(new THREE.CylinderGeometry(2.5 * ruler, 3 * ruler, 3 * ruler, 32, false, 0), new THREE.MeshPhongMaterial({
      color: 0x555555
    }));
    this.lens.castShadow = true; //default is false
    this.lens.receiveShadow = true; //default
    this.lens.position.z = -6 * ruler;
    this.lens.rotation.x = Math.PI / 2;
    this.cameraObj.add(this.cameraBody, this.lens);

    this.cameraCase = new THREE.Object3D();
    this.cameraCase.add(this.cameraObj);
    this.cameraCase.position.set(50 * ruler, 75 * ruler, 50 * ruler);
    scene.add(this.cameraCase);
    //camCase.push(this.cameraCase);

    // manual aiming, from (-50,40,50) to (0,0,0)
    this.cameraCase.rotation.y = 0;
    this.cameraCase.rotation.x = 0;
    this.cameraCase.rotation.z = 0;
    this.cameraCase.rotation.order = 'YXZ'
  }
}

$('#butPower').click(function() {
  butPower = !butPower;

  if (butYL == true && butPower == true) {
    yardLight.forEach(function(l) {
      l.intensity = YLBrightness;
    })
  } else {
    yardLight.forEach(function(l) {
      l.intensity = 0;
    })
  }

  if (butLamp == true && butPower == true) {
    lamp.forEach(function(l) {
      l.light.intensity = lampBrightness;
    })
  } else {
    lamp.forEach(function(l) {
      l.light.intensity = 0;
    })
  }
});

$('#butYL').click(function() {
  butYL = !butYL;

  if (butYL == true && butPower == true) {
    yardLight.forEach(function(l) {
      l.intensity = YLBrightness;
    })
  } else {
    yardLight.forEach(function(l) {
      l.intensity = 0;
    })
  }
});

$('#YLBrightness').change(function() {
  YLBrightness = $(this).val();
  if (butYL == true && butPower == true)
    yardLight.forEach(function(l) {
      l.intensity = YLBrightness;
    })
});

$('#butLamp').click(function() {
  butLamp = !butLamp;

  if (butLamp == true && butPower == true) {
    lamp.forEach(function(l) {
      l.light.intensity = lampBrightness;
    })
  } else {
    lamp.forEach(function(l) {
      l.light.intensity = 0;
    })
  }
});

$('#lampBrightness').change(function() {
  lampBrightness = $(this).val();
  if (butLamp == true && butPower == true)
    lamp.forEach(function(l) {
      l.light.intensity = lampBrightness;
    })
});

init();
animate();

function init() {

  renderer = new THREE.WebGLRenderer({
    antialias: true
  });
  var ww = $('#container').innerWidth();
  var hh = $('#container').innerHeight();
  renderer.setSize(ww, hh);
  renderer.setClearColor(0x888888);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap
  $('#container').append(renderer.domElement);

  renderer2 = new THREE.WebGLRenderer({
    antialias: true
  });
  var ww2 = $('#container2').innerWidth();
  var hh2 = $('#container2').innerHeight();
  renderer2.setSize(ww2, hh2);
  renderer2.setClearColor(0x888888);
  renderer2.shadowMap.enabled = true;
  renderer2.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap
  $('#container2').append(renderer2.domElement);

  renderer3 = new THREE.WebGLRenderer({
    antialias: true
  });
  var ww3 = $('#container3').innerWidth();
  var hh3 = $('#container3').innerHeight();
  renderer3.setSize(ww3, hh3);
  renderer3.setClearColor(0x888888);
  renderer3.shadowMap.enabled = true;
  renderer3.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap
  $('#container3').append(renderer3.domElement);
  
  renderer4 = new THREE.WebGLRenderer({
    antialias: true
  });
  var ww4 = $('#container4').innerWidth();
  var hh4 = $('#container4').innerHeight();
  renderer4.setSize(ww4, hh4);
  renderer4.setClearColor(0x888888);
  renderer4.shadowMap.enabled = true;
  renderer4.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap
  $('#container4').append(renderer4.domElement);

  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(50, $('#container').innerWidth() / $('#container').innerHeight(), 1, 1000);
  camera.position.z = 1500 * ruler;
  camera.position.y = 1500 * ruler;
  cameras.push(camera);
  camCase.push(null);
  angles.push(null);
  anglesCheck.push(null)
  signs.push(1);

  controls = new THREE.OrbitControls(camera, renderer.domElement);

  //////myScene//////
  //ambientlight
  var ambientLight = new THREE.AmbientLight(0xffffff, 0.4); // soft white light
  scene.add(ambientLight);

  let loader = new THREE.TextureLoader();
  loader.crossOrigin = '';
  texture = loader.load('https://i.imgur.com/tcP774R.jpg?1');
  texture.repeat.set(5, 5);
  texture.wrapS = texture.wrapT = true;

  var floor = new THREE.Mesh(new THREE.PlaneGeometry(1500 * ruler, 1500 * ruler), new THREE.MeshPhongMaterial({
    map: texture,
    side: THREE.DoubleSide
  }));
  floor.rotateX(Math.PI / 2);
  shadow(floor, false, true);
  floor.position.y = -0.05;
  scene.add(floor);
  floor.castShadow = true; //default is false
  floor.receiveShadow = true; //default

  var ceiling = new THREE.Mesh(new THREE.BoxGeometry(1540 * ruler, 50 * ruler, 1540 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff,
    opacity: 0.3,
    transparent: true,
    side: THREE.DoubleSide
  }));
  ceiling.position.y = 325 * ruler;
  scene.add(ceiling);
  ceiling.castShadow = true; //default is false
  ceiling.receiveShadow = true; //default

  var wall;
  wall = new THREE.Mesh(new THREE.BoxGeometry(1540 * ruler, 300 * ruler, 20 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  wall.position.set(0, 300 / 2 * ruler, (-(1500 + 20) / 2) * ruler);
  shadow(wall, false, true);
  scene.add(wall);

  wall = new THREE.Mesh(new THREE.BoxGeometry(20 * ruler, 300 * ruler, 1540 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  wall.position.set((-(1500 + 20) / 2) * ruler, 300 / 2 * ruler, 0);
  shadow(wall, false, true);
  scene.add(wall);

  wall = new THREE.Mesh(new THREE.BoxGeometry(20 * ruler, 300 * ruler, 1540 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  wall.position.set(((1500 + 20) / 2) * ruler, 300 / 2 * ruler, 0);
  shadow(wall, false, true);
  scene.add(wall);

  wall = new THREE.Mesh(new THREE.BoxGeometry(600 * ruler, 300 * ruler, 20 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  wall.position.set((-(1500 - 600) / 2) * ruler, 300 / 2 * ruler, ((1500 + 20) / 2) * ruler);
  shadow(wall, false, true);
  scene.add(wall);

  wall = new THREE.Mesh(new THREE.BoxGeometry(600 * ruler, 300 * ruler, 20 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  wall.position.set(((1500 - 600) / 2) * ruler, 300 / 2 * ruler, ((1500 + 20) / 2) * ruler);
  shadow(wall, false, true);
  scene.add(wall);

  wall = new THREE.Mesh(new THREE.BoxGeometry(20 * ruler, 300 * ruler, 300 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  wall.position.set((300 + 20) / 2 * ruler, 300 / 2 * ruler, ((1500 - 300) / 2) * ruler);
  shadow(wall, true, true);
  scene.add(wall);

  wall = new THREE.Mesh(new THREE.BoxGeometry(20 * ruler, 300 * ruler, 200 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  wall.position.set((-(300 + 20) / 2) * ruler, 300 / 2 * ruler, ((1500 - 200) / 2) * ruler);
  shadow(wall, true, true);
  scene.add(wall);

  var innerWall;
  innerWall = new THREE.Mesh(new THREE.BoxGeometry(20 * ruler, 300 * ruler, 220 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  innerWall.position.set(-((300 + 20) / 2 + 200) * ruler, 300 / 2 * ruler, (((1500 - 220) / 2) - 200) * ruler);
  shadow(innerWall, true, true);
  scene.add(innerWall);

  innerWall = new THREE.Mesh(new THREE.BoxGeometry(20 * ruler, 300 * ruler, 300 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  innerWall.position.set(290 * ruler, 300 / 2 * ruler, (((1500 - 320) / 2) - 110) * ruler);
  shadow(innerWall, true, true);
  scene.add(innerWall);

  innerWall = new THREE.Mesh(new THREE.BoxGeometry(640 * ruler, 300 * ruler, 20 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  innerWall.position.set(-30 * ruler, 300 / 2 * ruler, (((1500 + 20) / 2) - 420) * ruler);
  shadow(innerWall, true, true);
  scene.add(innerWall);

  innerWall = new THREE.Mesh(new THREE.BoxGeometry(60 * ruler, 300 * ruler, 300 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  innerWall.position.set(520 * ruler, 300 / 2 * ruler, (((1500 - 320) / 2) - 110) * ruler);
  shadow(innerWall, true, true);
  scene.add(innerWall);

  innerWall = new THREE.Mesh(new THREE.BoxGeometry(60 * ruler, 300 * ruler, 700 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  innerWall.position.set(520 * ruler, 300 / 2 * ruler, (480 - 150 - 100 - 350) * ruler);
  shadow(innerWall, true, true);
  scene.add(innerWall);

  innerWall = new THREE.Mesh(new THREE.BoxGeometry(60 * ruler, 300 * ruler, 480 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  innerWall.position.set(270 * ruler, 300 / 2 * ruler, (480 - 150 - 240) * ruler);
  shadow(innerWall, true, true);
  scene.add(innerWall);

  innerWall = new THREE.Mesh(new THREE.BoxGeometry(60 * ruler, 300 * ruler, 400 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  innerWall.position.set(270 * ruler, 300 / 2 * ruler, -450 * ruler);
  shadow(innerWall, true, true);
  scene.add(innerWall);

  innerWall = new THREE.Mesh(new THREE.BoxGeometry(600 * ruler, 300 * ruler, 100 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  innerWall.position.set(-285 * ruler, 300 / 2 * ruler, 0 * ruler);
  shadow(innerWall, true, true);
  scene.add(innerWall);

  innerWall = new THREE.Mesh(new THREE.BoxGeometry(600 * ruler, 300 * ruler, 100 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  innerWall.position.set(-285 * ruler, 300 / 2 * ruler, -400 * ruler);
  shadow(innerWall, true, true);
  scene.add(innerWall);

  //////lamps//////
  lamp.push(new NewLamp(2 * ruler, 0x999999, 0xffffff, 0.3));
  lamp[0].box.rotateZ(-Math.PI / 180 * 70);
  lamp[0].box.position.set(-500 * ruler, 265 * ruler, 550 * ruler);

  lamp.push(new NewLamp(2 * ruler, 0x999999, 0xffffff, 0.3));
  lamp[1].box.rotateZ(-Math.PI / 180 * 70);
  lamp[1].box.position.set(-500 * ruler, 265 * ruler, 175 * ruler);

  /*lamp.push(new NewLamp(2 * ruler, 0x999999, 0xbb3700, 1));
  lamp[2].box.rotateZ(-Math.PI / 3);
  lamp[2].box.position.set(-600 * ruler, 250 * ruler, -190 * ruler);*/

  //////yardLight//////
  var plPower = 600*ruler;
  yardLight.push(new THREE.PointLight(0xffffff, 0.5, plPower, 2));
  yardLight[0].castShadow = true;
  yardLight[0].position.set(-500 * ruler, 295 * ruler, 550 * ruler);

  yardLight.push(new THREE.PointLight(0xffffff, 0.5, plPower, 2));
  yardLight[1].castShadow = true;
  yardLight[1].position.set(-500 * ruler, 295 * ruler, 250 * ruler);

  yardLight.push(new THREE.PointLight(0xffffff, 0.5, plPower, 2));
  yardLight[2].castShadow = true;
  yardLight[2].position.set(-500 * ruler, 295 * ruler, -190 * ruler);
  
  yardLight.push(new THREE.PointLight(0xffffff, 0.5, plPower, 2));
  yardLight[3].castShadow = true;
  yardLight[3].position.set(-500 * ruler, 295 * ruler, -580 * ruler);

  yardLight.forEach(function(yL, i) {
    scene.add(yL);
    pointLightHelper.push(new THREE.PointLightHelper(yL, 2));
    scene.add(pointLightHelper[i]);
  })

  //////cameras//////
  var myCamera;
  myCamera = new NewCamera();
  cameras.push(myCamera.sCam);
  camCase.push(myCamera.cameraCase);
  camCase[1].position.set(-725 * ruler, 275 * ruler, 725 * ruler);
  camCase[1].rotation.y = -Math.PI / 3;
  camCase[1].rotation.x = -Math.PI / 6;
  camCase[1].rotation.z = 0;
  angles.push(camCase[1].rotation.y);
  anglesCheck.push(camCase[1].rotation.y)
  signs.push(1);

  myCamera = new NewCamera();
  cameras.push(myCamera.sCam);
  camCase.push(myCamera.cameraCase);
  camCase[2].position.set(225 * ruler, 275 * ruler, 300 * ruler);
  camCase[2].rotation.y = Math.PI / 4;
  camCase[2].rotation.x = -Math.PI / 6;
  camCase[2].rotation.z = 0;
  angles.push(camCase[2].rotation.y);
  anglesCheck.push(camCase[2].rotation.y)
  signs.push(1);
  
  myCamera = new NewCamera();
  cameras.push(myCamera.sCam);
  camCase.push(myCamera.cameraCase);
  camCase[3].position.set(-700 * ruler, 275 * ruler, -700 * ruler);
  camCase[3].rotation.y = Math.PI/6*7;
  camCase[3].rotation.x = -Math.PI / 6;
  camCase[3].rotation.z = 0;
  angles.push(camCase[3].rotation.y);
  anglesCheck.push(camCase[3].rotation.y)
  signs.push(1);
  
  //pictures
  texture = loader.load('img/c895010chara1.jpg');
  texture.repeat.set(1, 1);
  texture.wrapS = texture.wrapT = true;
  var pic = new THREE.Mesh(new THREE.PlaneGeometry(200 * ruler, 240 * ruler), new THREE.MeshPhongMaterial({
    map: texture,
    side: THREE.DoubleSide
  }));
  shadow(floor, false, true);
  pic.rotation.y = Math.PI/2;
  //pic.castShadow = true; //default is false
  pic.receiveShadow = true; //default
  pic.name = "朝武 芳乃";
  pickables.push (pic);
  pickables[0].position.set(-745 * ruler, 140 * ruler, 550 * ruler);//lamp[0].box.position.set(-500 * ruler, 265 * ruler, 475 * ruler);
  scene.add(pickables[0]);
  cameraOfPic = new THREE.PerspectiveCamera(50, $('#container').innerWidth() / $('#container').innerHeight(), 1, 1000);
  cameraOfPic.position.set(-450 * ruler, 150 * ruler, 550 * ruler);
  cameraOfPic.lookAt(new THREE.Vector3(-745 * ruler, 140 * ruler, 550 * ruler));
  camerasOfPic.push(cameraOfPic);
  
  texture = loader.load('img/c895010chara3.jpg');
  texture.repeat.set(1, 1);
  texture.wrapS = texture.wrapT = true;
  pic = new THREE.Mesh(new THREE.PlaneGeometry(200 * ruler, 240 * ruler), new THREE.MeshPhongMaterial({
    map: texture,
    side: THREE.DoubleSide
  }));
  shadow(floor, false, true);
  pic.rotation.y = Math.PI/2;
  //pic.castShadow = true; //default is false
  pic.receiveShadow = true; //default
  pic.name = "ムラサメ";
  pickables.push (pic);
  pickables[1].position.set(-745 * ruler, 140 * ruler, 175 * ruler);//lamp[1].box.position.set(-500 * ruler, 265 * ruler, 175 * ruler);
  scene.add(pickables[1]);
  cameraOfPic = new THREE.PerspectiveCamera(50, $('#container').innerWidth() / $('#container').innerHeight(), 1, 1000);
  cameraOfPic.position.set(-450 * ruler, 150 * ruler, 175 * ruler);
  cameraOfPic.lookAt(new THREE.Vector3(-745 * ruler, 140 * ruler, 175 * ruler));
  camerasOfPic.push(cameraOfPic);
  

  window.addEventListener('resize', onWindowResize, false);
  window.addEventListener('mousedown', onDocumentMouseDown, false);

}

function onWindowResize() {
  var ww = $('#container').innerWidth();
  var hh = $('#container').innerHeight();
  camera.aspect = ww / hh;
  camera.updateProjectionMatrix();
  renderer.setSize(ww, hh);

  var ww2 = $('#container2').innerWidth();
  var hh2 = $('#container2').innerHeight();
  camera2.aspect = ww2 / hh2;
  camera2.updateProjectionMatrix();
  renderer2.setSize(ww2, hh2);

  var ww3 = $('#container3').innerWidth();
  var hh3 = $('#container3').innerHeight();
  camera3.aspect = ww3 / hh3;
  camera3.updateProjectionMatrix();
  renderer3.setSize(ww3, hh3);
  
  var ww4 = $('#container4').innerWidth();
  var hh4 = $('#container4').innerHeight();
  camera4.aspect = ww4 / hh4;
  camera4.updateProjectionMatrix();
  renderer4.setSize(ww4, hh4);
}

function onDocumentMouseDown(event) {

  //event.preventDefault();

  // many unsuccessful tries ...
  /*
    mouse.x = ((event.clientX - event.target.offsetLeft) / $('#container').innerWidth()) * 2 - 1;
    mouse.y = -((event.clientY - event.target.offsetTop) / $('#container').innerHeight()) * 2 + 1;
  */

  var viewportPos = $('#container').get(0).getBoundingClientRect();
  mouse.x = ((event.clientX - viewportPos.left) / $('#container').innerWidth()) * 2 - 1;
  mouse.y = -((event.clientY - viewportPos.top) / $('#container').innerHeight()) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);
  var intersects = raycaster.intersectObjects(pickables);
  if (intersects.length > 0) {
    //cyl.position.copy(intersects[0].point);
    //alert(intersects[0].object.name + " is picked!");
	for(var cc = 0; cc < pickables.length; cc++){
		if(camera == cameras[0])
			if(intersects[0].object.name == pickables[cc].name){
				camera = camerasOfPic[cc];
				//infoText = $("#pictureInfos[cc]");
				//infoText.html(pictureInfo.html().replace(/\n/g,'<br/>'));
				//$("#pictureInfo").text(infoText);
				
				informationText = $("#pictureInfo").text(pictureInfos[cc]);
				informationText.html(informationText.html().replace(/\n/g,'<br/>'));
			}
	}
  }
}

function animate() {
  requestAnimationFrame(animate);
  render();
}

function render() {

  for (let cc = 0; cc < angles.length; cc++) {
    if (angles[cc] != null && anglesCheck[cc] != null) {
      angles[cc] += 0.0035 * signs[cc];
      if (angles[cc] > anglesCheck[cc] + 0.5 || angles[cc] < anglesCheck[cc] - 0.5)
        signs[cc] *= -1;
      if (camCase[cc] != null)
        camCase[cc].rotation.y = angles[cc];
    }
  }

  for (let cc = 0; cc < camCase.length; cc++) {
    if (camCase[cc] != null) {
      cameras[cc].matrixWorld.copy(camCase[cc].matrixWorld);
      cameras[cc].matrixAutoUpdate = false;
    }
  }

  renderer.render(scene, camera);

  camera2 = cameras[1];
  renderer2.render(scene, camera2);
  camera3 = cameras[2];
  renderer3.render(scene, camera3);
  camera4 = cameras[3];
  renderer4.render(scene, camera4);
}

function shadow(Object, castShadow, receiveShadow) {
  Object.castShadow = castShadow;
  Object.receiveShadow = receiveShadow;
}


</script>

</body>
</html>


