<!DOCTYPE html>
<html>
<head>
<style>
#container {
  width: 50vw;
  height: 50vw;
  float: left;
  background-color: yellow;
  margin: 1vw;
}

#container2 {
  width: 20vw;
  height: 20vw;
  float: left;
  background-color: red;
  margin: 1vw;
}

#container3 {
  width: 20vw;
  height: 20vw;
  float: left;
  background-color: red;
  margin: 1vw;
}

p {
  margin: 10px;
  text-align: justify;
}

</style>
</head>
<body>
<h1 style="font-size:2em; text-align:center; margin:15px">
  Hw3
</h1>
<hr>
<div id="container">
  <!--canvas id='mycanvas'></canvas-->
</div>

<button id="butPower" style="width:40vw">Power Button</button>
<br><button id="butYL" style="width:15vw">YardLight Button</button>
<input type=range min=0.1 max=1 step=0.1 id='YLBrightness' style="width:15vw"> Brightness
<br><button id="butLamp" style="width:15vw">Lamp Button</button>
<input type=range min=0.1 max=0.7 step=0.1 id='lampBrightness' style="width:15vw"> Brightness
<br><button id="defaultCam" style="width:20vw">Default Camera</button><button id="switchCam" style="width:20vw">Camera Switch</button>

<div id="container2">
  <!--canvas id='mycanvas'></canvas-->
</div>

<div id="container3">
  <!--canvas id='mycanvas'></canvas-->
</div>

<p>
  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur quam lectus, porta eget tincidunt eget, auctor eget lorem. Cras sed est eu tellus consequat semper a ac dolor. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Maecenas feugiat
  luctus augue sed pellentesque. In laoreet tincidunt lacinia. In pellentesque egestas enim ut auctor. Mauris et urna at est varius faucibus quis at sapien. Nam hendrerit velit at bibendum fringilla. Sed ut dignissim dui, eget sagittis est. Pellentesque
  varius nibh ut nunc condimentum viverra. Fusce erat felis, laoreet vitae ex sit amet, venenatis lobortis nibh. Suspendisse lectus massa, malesuada vel ullamcorper sed, iaculis eu dolor. Donec accumsan diam non dolor aliquet, a cursus arcu hendrerit.
  Quisque accumsan sed quam at dictum.
</p>
<br>
<p>
  Nullam finibus felis et varius mollis. Donec sapien tellus, lacinia sit amet orci non, posuere laoreet nunc. Vivamus gravida turpis est, vulputate sagittis leo facilisis in. Sed aliquet ornare gravida. Nullam eget velit et lacus lacinia eleifend quis
  in metus. Vestibulum nec congue libero. Duis eu quam eu sem fermentum dapibus et vel ex. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae;
</p>
<hr>
<p>
  Vivamus et leo non turpis varius blandit. Aliquam sed metus ac nisl elementum fermentum et suscipit mauris. Curabitur nulla justo, aliquam at arcu nec, ullamcorper rutrum massa. Nam malesuada massa lorem, laoreet consectetur tortor fringilla quis. Ut
  in lacinia diam, ut elementum libero. Quisque tempor libero eget felis malesuada malesuada. In efficitur, ipsum id lacinia fermentum, tortor enim rhoncus ipsum, ac lobortis magna neque et neque. Class aptent taciti sociosqu ad litora torquent per conubia
  nostra, per inceptos himenaeos. Cras est dolor, condimentum tincidunt molestie at, fringilla quis velit.
</p>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/84/three.min.js"></script>
<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
<script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5/dat.gui.min.js"></script>
<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>

<script>

var scene, renderer, rederer2, rederer3, camera, camera2, camera3;
var cameraOfPic;
var ruler = 0.2;
var lamp = [];
var yardLight = [];
var pointLightHelper = [];
var butPower = true;
var YLBrightness = 0.5;
var butYL = true;
var lampBrightness = 1.5;
var butLamp = true;
var angle = 0;
var sign = 1;
var cameras = [];
var counter = 0;
var camCase = [];
var angles = [];
var anglesCheck = [];
var signs = [];
var mouse = new THREE.Vector2();
var raycaster = new THREE.Raycaster();
var pickables = [];
var camerasOfPic = [];

class NewLamp {
  constructor(size, color, lightColor, lightPow) {
    this.box = new THREE.Mesh(new THREE.BoxGeometry(1 * size, 1 * size, 1 * size), new THREE.MeshPhongMaterial({
      color: color
    }));

    var tower = new THREE.Mesh(new THREE.CylinderGeometry(2 * size, 4 * size, 10 * size, 32, false, 0), new THREE.MeshPhongMaterial({
      color: color,
      side: THREE.DoubleSide
    }));
    this.box.add(tower);
    tower.castShadow = true; //default is false
    tower.receiveShadow = true; //default
    tower.position.y = -5 * size;

    var top = new THREE.Mesh(new THREE.CylinderGeometry(2 * size, 2 * size, 1 * size, 32), new THREE.MeshPhongMaterial({
      color: color,
      side: THREE.DoubleSide
    }));
    top.castShadow = true; //default is false
    top.receiveShadow = false; //default
    this.box.add(top);

    var bulb = new THREE.Mesh(new THREE.SphereGeometry(1 * size, 32, 32), new THREE.MeshPhongMaterial({
      color: 0x555555,
      opacity: 0.3,
      transparent: true,
      side: THREE.DoubleSide
    }));
    this.box.add(bulb);
    bulb.position.y = -2 * size;

    this.light = new THREE.PointLight(lightColor, lightPow, 0, 2);
    this.light.castShadow = true;
    this.box.add(this.light);
    this.light.position.y = -2 * size;

    scene.add(this.box);
  }
}

$("#defaultCam").click(function() {
  counter = 0;
  camera = cameras[counter];
});

$("#switchCam").click(function() {
  counter++;
  if (counter >= cameras.length)
    counter = 0;
  camera = cameras[counter];
});

class NewCamera {
  constructor() {
    this.sCam = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
    //cameras.push(sCam);

    this.cameraObj = new THREE.Object3D();
    //this.cameraObj.add(new THREE.AxisHelper(40))
    this.cameraBody = new THREE.Mesh(new THREE.BoxGeometry(5 * ruler, 5 * ruler, 10 * ruler), new THREE.MeshPhongMaterial({
      color: 0x555555
    }));
    this.cameraBody.castShadow = true; //default is false
    this.cameraBody.receiveShadow = true; //default
    this.lens = new THREE.Mesh(new THREE.CylinderGeometry(2.5 * ruler, 3 * ruler, 3 * ruler, 32, false, 0), new THREE.MeshPhongMaterial({
      color: 0x555555
    }));
    this.lens.castShadow = true; //default is false
    this.lens.receiveShadow = true; //default
    this.lens.position.z = -6 * ruler;
    this.lens.rotation.x = Math.PI / 2;
    this.cameraObj.add(this.cameraBody, this.lens);

    this.cameraCase = new THREE.Object3D();
    this.cameraCase.add(this.cameraObj);
    this.cameraCase.position.set(50 * ruler, 75 * ruler, 50 * ruler);
    scene.add(this.cameraCase);
    //camCase.push(this.cameraCase);

    // manual aiming, from (-50,40,50) to (0,0,0)
    this.cameraCase.rotation.y = 0;
    this.cameraCase.rotation.x = 0;
    this.cameraCase.rotation.z = 0;
    this.cameraCase.rotation.order = 'YXZ'
  }
}

$('#butPower').click(function() {
  butPower = !butPower;

  if (butYL == true && butPower == true) {
    yardLight.forEach(function(l) {
      l.intensity = YLBrightness;
    })
  } else {
    yardLight.forEach(function(l) {
      l.intensity = 0;
    })
  }

  if (butLamp == true && butPower == true) {
    lamp.forEach(function(l) {
      l.light.intensity = lampBrightness;
    })
  } else {
    lamp.forEach(function(l) {
      l.light.intensity = 0;
    })
  }
});

$('#butYL').click(function() {
  butYL = !butYL;

  if (butYL == true && butPower == true) {
    yardLight.forEach(function(l) {
      l.intensity = YLBrightness;
    })
  } else {
    yardLight.forEach(function(l) {
      l.intensity = 0;
    })
  }
});

$('#YLBrightness').change(function() {
  YLBrightness = $(this).val();
  if (butYL == true && butPower == true)
    yardLight.forEach(function(l) {
      l.intensity = YLBrightness;
    })
});

$('#butLamp').click(function() {
  butLamp = !butLamp;

  if (butLamp == true && butPower == true) {
    lamp.forEach(function(l) {
      l.light.intensity = lampBrightness;
    })
  } else {
    lamp.forEach(function(l) {
      l.light.intensity = 0;
    })
  }
});

$('#lampBrightness').change(function() {
  lampBrightness = $(this).val();
  if (butLamp == true && butPower == true)
    lamp.forEach(function(l) {
      l.light.intensity = lampBrightness;
    })
});

init();
animate();

function init() {

  renderer = new THREE.WebGLRenderer({
    antialias: true
  });
  var ww = $('#container').innerWidth();
  var hh = $('#container').innerHeight();
  renderer.setSize(ww, hh);
  renderer.setClearColor(0x888888);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap
  $('#container').append(renderer.domElement);

  renderer2 = new THREE.WebGLRenderer({
    antialias: true
  });
  var ww2 = $('#container2').innerWidth();
  var hh2 = $('#container2').innerHeight();
  renderer2.setSize(ww2, hh2);
  renderer2.setClearColor(0x888888);
  renderer2.shadowMap.enabled = true;
  renderer2.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap
  $('#container2').append(renderer2.domElement);

  renderer3 = new THREE.WebGLRenderer({
    antialias: true
  });
  var ww3 = $('#container3').innerWidth();
  var hh3 = $('#container3').innerHeight();
  renderer3.setSize(ww3, hh3);
  renderer3.setClearColor(0x888888);
  renderer3.shadowMap.enabled = true;
  renderer3.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap
  $('#container3').append(renderer3.domElement);

  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(50, $('#container').innerWidth() / $('#container').innerHeight(), 1, 1000);
  camera.position.z = 1500 * ruler;
  camera.position.y = 1500 * ruler;
  cameras.push(camera);
  camCase.push(null);
  angles.push(null);
  anglesCheck.push(null)
  signs.push(1);

  controls = new THREE.OrbitControls(camera, renderer.domElement);

  //////myScene//////
  //ambientlight
  var ambientLight = new THREE.AmbientLight(0xffffff, 0.2); // soft white light
  scene.add(ambientLight);

  let loader = new THREE.TextureLoader();
  loader.crossOrigin = '';
  texture = loader.load('https://i.imgur.com/tcP774R.jpg?1');
  texture.repeat.set(5, 5);
  texture.wrapS = texture.wrapT = true;

  var floor = new THREE.Mesh(new THREE.PlaneGeometry(1500 * ruler, 1500 * ruler), new THREE.MeshPhongMaterial({
    map: texture,
    side: THREE.DoubleSide
  }));
  floor.rotateX(Math.PI / 2);
  shadow(floor, false, true);
  floor.position.y = -0.05;
  scene.add(floor);
  floor.castShadow = true; //default is false
  floor.receiveShadow = true; //default

  var ceiling = new THREE.Mesh(new THREE.BoxGeometry(1540 * ruler, 50 * ruler, 1540 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff,
    opacity: 0.5,
    transparent: true,
    side: THREE.DoubleSide
  }));
  ceiling.position.y = 325 * ruler;
  scene.add(ceiling);
  ceiling.castShadow = true; //default is false
  ceiling.receiveShadow = true; //default

  var wall;
  wall = new THREE.Mesh(new THREE.BoxGeometry(1540 * ruler, 300 * ruler, 20 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  wall.position.set(0, 300 / 2 * ruler, (-(1500 + 20) / 2) * ruler);
  shadow(wall, false, true);
  scene.add(wall);

  wall = new THREE.Mesh(new THREE.BoxGeometry(20 * ruler, 300 * ruler, 1540 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  wall.position.set((-(1500 + 20) / 2) * ruler, 300 / 2 * ruler, 0);
  shadow(wall, false, true);
  scene.add(wall);

  wall = new THREE.Mesh(new THREE.BoxGeometry(20 * ruler, 300 * ruler, 1540 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  wall.position.set(((1500 + 20) / 2) * ruler, 300 / 2 * ruler, 0);
  shadow(wall, false, true);
  scene.add(wall);

  wall = new THREE.Mesh(new THREE.BoxGeometry(600 * ruler, 300 * ruler, 20 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  wall.position.set((-(1500 - 600) / 2) * ruler, 300 / 2 * ruler, ((1500 + 20) / 2) * ruler);
  shadow(wall, false, true);
  scene.add(wall);

  wall = new THREE.Mesh(new THREE.BoxGeometry(600 * ruler, 300 * ruler, 20 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  wall.position.set(((1500 - 600) / 2) * ruler, 300 / 2 * ruler, ((1500 + 20) / 2) * ruler);
  shadow(wall, false, true);
  scene.add(wall);

  wall = new THREE.Mesh(new THREE.BoxGeometry(20 * ruler, 300 * ruler, 300 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  wall.position.set((300 + 20) / 2 * ruler, 300 / 2 * ruler, ((1500 - 300) / 2) * ruler);
  shadow(wall, true, true);
  scene.add(wall);

  wall = new THREE.Mesh(new THREE.BoxGeometry(20 * ruler, 300 * ruler, 200 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  wall.position.set((-(300 + 20) / 2) * ruler, 300 / 2 * ruler, ((1500 - 200) / 2) * ruler);
  shadow(wall, true, true);
  scene.add(wall);

  var innerWall;
  innerWall = new THREE.Mesh(new THREE.BoxGeometry(20 * ruler, 300 * ruler, 220 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  innerWall.position.set(-((300 + 20) / 2 + 200) * ruler, 300 / 2 * ruler, (((1500 - 220) / 2) - 200) * ruler);
  shadow(innerWall, true, true);
  scene.add(innerWall);

  innerWall = new THREE.Mesh(new THREE.BoxGeometry(20 * ruler, 300 * ruler, 300 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  innerWall.position.set(290 * ruler, 300 / 2 * ruler, (((1500 - 320) / 2) - 110) * ruler);
  shadow(innerWall, true, true);
  scene.add(innerWall);

  innerWall = new THREE.Mesh(new THREE.BoxGeometry(640 * ruler, 300 * ruler, 20 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  innerWall.position.set(-30 * ruler, 300 / 2 * ruler, (((1500 + 20) / 2) - 420) * ruler);
  shadow(innerWall, true, true);
  scene.add(innerWall);

  innerWall = new THREE.Mesh(new THREE.BoxGeometry(60 * ruler, 300 * ruler, 300 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  innerWall.position.set(520 * ruler, 300 / 2 * ruler, (((1500 - 320) / 2) - 110) * ruler);
  shadow(innerWall, true, true);
  scene.add(innerWall);

  innerWall = new THREE.Mesh(new THREE.BoxGeometry(60 * ruler, 300 * ruler, 700 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  innerWall.position.set(520 * ruler, 300 / 2 * ruler, (480 - 150 - 100 - 350) * ruler);
  shadow(innerWall, true, true);
  scene.add(innerWall);

  innerWall = new THREE.Mesh(new THREE.BoxGeometry(60 * ruler, 300 * ruler, 480 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  innerWall.position.set(270 * ruler, 300 / 2 * ruler, (480 - 150 - 240) * ruler);
  shadow(innerWall, true, true);
  scene.add(innerWall);

  innerWall = new THREE.Mesh(new THREE.BoxGeometry(60 * ruler, 300 * ruler, 400 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  innerWall.position.set(270 * ruler, 300 / 2 * ruler, -450 * ruler);
  shadow(innerWall, true, true);
  scene.add(innerWall);

  innerWall = new THREE.Mesh(new THREE.BoxGeometry(600 * ruler, 300 * ruler, 100 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  innerWall.position.set(-285 * ruler, 300 / 2 * ruler, 0 * ruler);
  shadow(innerWall, true, true);
  scene.add(innerWall);

  innerWall = new THREE.Mesh(new THREE.BoxGeometry(600 * ruler, 300 * ruler, 100 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  innerWall.position.set(-285 * ruler, 300 / 2 * ruler, -400 * ruler);
  shadow(innerWall, true, true);
  scene.add(innerWall);

  //////lamps//////
  lamp.push(new NewLamp(2 * ruler, 0x999999, 0xffffff, 0.3));
  lamp[0].box.rotateZ(-Math.PI / 180 * 70);
  lamp[0].box.position.set(-500 * ruler, 265 * ruler, 475 * ruler);

  lamp.push(new NewLamp(2 * ruler, 0x999999, 0xffffff, 0.3));
  lamp[1].box.rotateZ(-Math.PI / 180 * 70);
  lamp[1].box.position.set(-500 * ruler, 265 * ruler, 175 * ruler);

  /*lamp.push(new NewLamp(2 * ruler, 0x999999, 0xbb3700, 1));
  lamp[2].box.rotateZ(-Math.PI / 3);
  lamp[2].box.position.set(-600 * ruler, 250 * ruler, -190 * ruler);*/

  //////yardLight//////
  yardLight.push(new THREE.PointLight(0xffffff, 0.5, 750*ruler, 2));
  yardLight[0].castShadow = true;
  yardLight[0].position.set(-500 * ruler, 295 * ruler, 550 * ruler);

  yardLight.push(new THREE.PointLight(0xffffff, 0.5, 750*ruler, 2));
  yardLight[1].castShadow = true;
  yardLight[1].position.set(-500 * ruler, 295 * ruler, 250 * ruler);

  /*yardLight.push(new THREE.PointLight(0x888888, 0.5, 0, 2));
  yardLight[2].castShadow = true;
  yardLight[2].position.set(-500 * ruler, 295 * ruler, -190 * ruler);*/

  yardLight.forEach(function(yL, i) {
    scene.add(yL);
    pointLightHelper.push(new THREE.PointLightHelper(yL, 2));
    scene.add(pointLightHelper[i]);
  })

  //////cameras//////
  var myCamera;
  myCamera = new NewCamera();
  cameras.push(myCamera.sCam);
  camCase.push(myCamera.cameraCase);
  camCase[1].position.set(-725 * ruler, 275 * ruler, 725 * ruler);
  camCase[1].rotation.y = -Math.PI / 3;
  camCase[1].rotation.x = -Math.PI / 6;
  camCase[1].rotation.z = 0;
  angles.push(camCase[1].rotation.y);
  anglesCheck.push(camCase[1].rotation.y)
  signs.push(1);

  myCamera = new NewCamera();
  cameras.push(myCamera.sCam);
  camCase.push(myCamera.cameraCase);
  camCase[2].position.set(225 * ruler, 275 * ruler, 300 * ruler);
  camCase[2].rotation.y = Math.PI / 4;
  camCase[2].rotation.x = -Math.PI / 6;
  camCase[2].rotation.z = 0;
  angles.push(camCase[2].rotation.y);
  anglesCheck.push(camCase[2].rotation.y)
  signs.push(1);
  
  //pictures
  texture = loader.load('img/c895010chara1.jpg');
  texture.repeat.set(1, 1);
  texture.wrapS = texture.wrapT = true;
  var pic = new THREE.Mesh(new THREE.PlaneGeometry(200 * ruler, 240 * ruler), new THREE.MeshPhongMaterial({
    map: texture,
    side: THREE.DoubleSide
  }));
  shadow(floor, false, true);
  pic.rotation.y = Math.PI/2;
  //pic.castShadow = true; //default is false
  pic.receiveShadow = true; //default
  pic.name = "朝武 芳乃";
  pickables.push (pic);
  pickables[0].position.set(-749 * ruler, 140 * ruler, 475 * ruler);//lamp[0].box.position.set(-500 * ruler, 265 * ruler, 475 * ruler);
  scene.add(pickables[0]);
  cameraOfPic = new THREE.PerspectiveCamera(50, $('#container').innerWidth() / $('#container').innerHeight(), 1, 1000);
  cameraOfPic.position.set(-350 * ruler, 150 * ruler, 475 * ruler);
  cameraOfPic.lookAt(new THREE.Vector3(-749 * ruler, 140 * ruler, 475 * ruler));
  camerasOfPic.push(cameraOfPic);
  
  texture = loader.load('img/c895010chara3.jpg');
  texture.repeat.set(1, 1);
  texture.wrapS = texture.wrapT = true;
  pic = new THREE.Mesh(new THREE.PlaneGeometry(200 * ruler, 240 * ruler), new THREE.MeshPhongMaterial({
    map: texture,
    side: THREE.DoubleSide
  }));
  shadow(floor, false, true);
  pic.rotation.y = Math.PI/2;
  //pic.castShadow = true; //default is false
  pic.receiveShadow = true; //default
  pic.name = "ムラサメ";
  pickables.push (pic);
  pickables[1].position.set(-749 * ruler, 140 * ruler, 175 * ruler);//lamp[1].box.position.set(-500 * ruler, 265 * ruler, 175 * ruler);
  scene.add(pickables[1]);
  cameraOfPic = new THREE.PerspectiveCamera(50, $('#container').innerWidth() / $('#container').innerHeight(), 1, 1000);
  cameraOfPic.position.set(-350 * ruler, 150 * ruler, 175 * ruler);
  cameraOfPic.lookAt(new THREE.Vector3(-749 * ruler, 140 * ruler, 175 * ruler));
  camerasOfPic.push(cameraOfPic);
  

  window.addEventListener('resize', onWindowResize, false);
  window.addEventListener('mousedown', onDocumentMouseDown, false);

}

function onWindowResize() {
  var ww = $('#container').innerWidth();
  var hh = $('#container').innerHeight();
  camera.aspect = ww / hh;
  camera.updateProjectionMatrix();
  renderer.setSize(ww, hh);

  var ww2 = $('#container2').innerWidth();
  var hh2 = $('#container2').innerHeight();
  camera2.aspect = ww2 / hh2;
  camera2.updateProjectionMatrix();
  renderer2.setSize(ww2, hh2);

  var ww3 = $('#container3').innerWidth();
  var hh3 = $('#container3').innerHeight();
  camera3.aspect = ww3 / hh3;
  camera3.updateProjectionMatrix();
  renderer3.setSize(ww3, hh3);
}

function onDocumentMouseDown(event) {

  //event.preventDefault();

  // many unsuccessful tries ...
  /*
    mouse.x = ((event.clientX - event.target.offsetLeft) / $('#container').innerWidth()) * 2 - 1;
    mouse.y = -((event.clientY - event.target.offsetTop) / $('#container').innerHeight()) * 2 + 1;
  */

  var viewportPos = $('#container').get(0).getBoundingClientRect();
  mouse.x = ((event.clientX - viewportPos.left) / $('#container').innerWidth()) * 2 - 1;
  mouse.y = -((event.clientY - viewportPos.top) / $('#container').innerHeight()) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);
  var intersects = raycaster.intersectObjects(pickables);
  if (intersects.length > 0) {
    //cyl.position.copy(intersects[0].point);
    //alert(intersects[0].object.name + " is picked!");
	for(var cc = 0; cc < pickables.length; cc++){
		if(intersects[0].object.name == pickables[cc].name){
			camera = camerasOfPic[cc];
		}
	}
  }
}

function animate() {
  requestAnimationFrame(animate);
  render();
}

function render() {

  for (let cc = 0; cc < angles.length; cc++) {
    if (angles[cc] != null && anglesCheck[cc] != null) {
      angles[cc] += 0.0035 * signs[cc];
      if (angles[cc] > anglesCheck[cc] + 0.5 || angles[cc] < anglesCheck[cc] - 0.5)
        signs[cc] *= -1;
      if (camCase[cc] != null)
        camCase[cc].rotation.y = angles[cc];
    }
  }

  for (let cc = 0; cc < camCase.length; cc++) {
    if (camCase[cc] != null) {
      cameras[cc].matrixWorld.copy(camCase[cc].matrixWorld);
      cameras[cc].matrixAutoUpdate = false;
    }
  }

  renderer.render(scene, camera);

  camera2 = cameras[1];
  renderer2.render(scene, camera2);
  camera3 = cameras[2];
  renderer3.render(scene, camera3);
}

function shadow(Object, castShadow, receiveShadow) {
  Object.castShadow = castShadow;
  Object.receiveShadow = receiveShadow;
}


</script>

</body>
</html>


