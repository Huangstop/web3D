<!DOCTYPE html>
<html>
<head>
<style>
#container {
  width: 40vw;
  height: 30vw;
  float: left;
  background-color: white;
  margin-left: 2vw;
}

#container2 {
  width: 16vw;
  height: 12vw;
  float: left;
  background-color: white;
  margin-top:1vw;
  margin-right:1vw;
  text-align:center;
  color:Red;
}

#container3 {
  width: 16vw;
  height: 12vw;
  float: left;
  background-color: white;
  margin-top:1vw;
  margin-right:1vw;
  text-align:center;
  color:Green;
}

#container4 {
  width: 16vw;
  height: 12vw;
  float: left;
  background-color: white;
  margin-top:1vw;
  margin-right:1vw;
  text-align:center;
  color:Blue;
}

#sCamContainer{
  width: 24vw;
  height: 18vw;
  margin-top: 1vw;
  background-color: white;
  position: absolute;
  top:0vw;
  left:20vw;
}

p {
  margin: 10px;
  text-align: justify;
}

</style>
</head>
<body>
<h1 style="font-size:2em; text-align:center; margin:15px">
<s>柚子社</s>&nbsp&nbsp千恋＊万花&nbsp&nbspキャラー紹介
</h1>
<hr>
<div style = "width:40vw;float:left">
<div id="container">
  <!--canvas id='mycanvas'></canvas-->
</div>
<div style="font-size:24px"> 角色說明: </div>
<div id="pictureInfo" style="font-size:16px">請點選上方畫面上的圖片<br>或是使用下拉式選單選取圖片</div>
</div>

<div style="width: 54vw;float: right">

<div style="width:40vw">

<!--<button id="butPower" style="width:40vw">Power Button</button>
<br><button id="butYL" style="width:20vw">YardLight Button</button><button id="butLamp" style="width:20vw">Lamp Button</button>
<input type=range min=0.1 max=1 step=0.1 id='YLBrightness' style="width:15vw"> Brightness
<button id="butLamp" style="width:20vw">Lamp Button</button>
<input type=range min=0.1 max=0.7 step=0.1 id='lampBrightness' style="width:15vw"> Brightness-->
<button id="defaultCam" style="width:20vw">Default Camera</button>
<select id="selectArt" style="font-size:16px;width:16vw;float:right">
<option value="0">Default Camera</option>
<option value="1">写真1</option>
<option value="2">写真2</option>
<option value="3">写真3</option>
<option value="4">写真4</option>
</select>
<!--<button id="switchCam" style="width:20vw">Camera Switch</button>-->

</div>
<div style = "width: 54vw; float: right;position: relative;">
	<div style = "width:18vw;height:18vw;margin-top:1vw;background-image: url( ' img/map.JPG ' );background-size:18vw 18vw;position: relative;" >
		<!--<img src="img/map.jpg" style="width:20vw;height:20vw;position:relative;z-index:-1">-->
		<div style = "width:18vw;height:18vw;">
			<input id="sCam1" type="button" style="width: 5%;height: 5%;top:93%;left:2%;background-color: Red;border-radius:100%;position:absolute;z-index:1;" />
			<input id="sCam2" type="button" style="width: 5%;height: 5%;top:65%;left:60%;background-color: Green;border-radius:100%;position:absolute;z-index:1" />
			<input id="sCam3" type="button" style="width: 5%;height: 5%;top:1%;left:2%;background-color: Blue;border-radius:100%;position:absolute;z-index:1" />
		</div>
	</div>

	<div id="sCamContainer">
	  <!--canvas id='mycanvas'></canvas-->
	</div>
</div>

<div id="container2">
  <!--canvas id='mycanvas'></canvas-->
  紅
</div>

<div id="container3">
  <!--canvas id='mycanvas'></canvas-->
  綠
</div>

<div id="container4">
  <!--canvas id='mycanvas'></canvas-->
  藍
</div>

<div style="width:50vw" style="margin-right:5vw">

</div>
</div>

<!--
<p>
  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur quam lectus, porta eget tincidunt eget, auctor eget lorem. Cras sed est eu tellus consequat semper a ac dolor. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Maecenas feugiat
  luctus augue sed pellentesque. In laoreet tincidunt lacinia. In pellentesque egestas enim ut auctor. Mauris et urna at est varius faucibus quis at sapien. Nam hendrerit velit at bibendum fringilla. Sed ut dignissim dui, eget sagittis est. Pellentesque
  varius nibh ut nunc condimentum viverra. Fusce erat felis, laoreet vitae ex sit amet, venenatis lobortis nibh. Suspendisse lectus massa, malesuada vel ullamcorper sed, iaculis eu dolor. Donec accumsan diam non dolor aliquet, a cursus arcu hendrerit.
  Quisque accumsan sed quam at dictum.
</p>
<br>

<p>
  Nullam finibus felis et varius mollis. Donec sapien tellus, lacinia sit amet orci non, posuere laoreet nunc. Vivamus gravida turpis est, vulputate sagittis leo facilisis in. Sed aliquet ornare gravida. Nullam eget velit et lacus lacinia eleifend quis
  in metus. Vestibulum nec congue libero. Duis eu quam eu sem fermentum dapibus et vel ex. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae;
</p>
<hr>
<p>
  Vivamus et leo non turpis varius blandit. Aliquam sed metus ac nisl elementum fermentum et suscipit mauris. Curabitur nulla justo, aliquam at arcu nec, ullamcorper rutrum massa. Nam malesuada massa lorem, laoreet consectetur tortor fringilla quis. Ut
  in lacinia diam, ut elementum libero. Quisque tempor libero eget felis malesuada malesuada. In efficitur, ipsum id lacinia fermentum, tortor enim rhoncus ipsum, ac lobortis magna neque et neque. Class aptent taciti sociosqu ad litora torquent per conubia
  nostra, per inceptos himenaeos. Cras est dolor, condimentum tincidunt molestie at, fringilla quis velit.
</p>
-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/84/three.min.js"></script>
<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
<script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5/dat.gui.min.js"></script>
<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>

<script>

var scene, renderer, rederer2, rederer3, renderer4, renderering, camera, camera2, camera3, camera4, sCamera;
var cameraOfPic;
var ruler = 0.2;
var lamp = [];
var yardLight = [];
var pointLightHelper = [];
var butPower = true;
var YLBrightness = 0.5;
var butYL = true;
var lampBrightness = 1.5;
var butLamp = true;
var angle = 0;
var sign = 1;
var cameras = [];
var counter = 0;
var camCase = [];
var angles = [];
var anglesCheck = [];
var signs = [];
var mouse = new THREE.Vector2();
var raycaster = new THREE.Raycaster();
var pickables = [];
var camerasOfPic = [];
var pictureInfos = [
"朝武 芳乃 （ともたけ よしの）　CV：遥そら\n穂織にある神社の巫女姫様。\n主人公が神刀をへし折ったことで、土地の掟に従ってムリヤリ婚約相手にされてしまう。\n生真面目な性格で若干クールに見られがちだが、実際は冷たい人間ではない。\n\n喜怒哀楽がわりとハッキリしていて、精神的には子供っぽい部分が多々ある。\n冷静沈着に振る舞おうとするものの、簡単なミスも多くて意外とヌケている。\n「～～～……とにかく、結婚なんてしませんから。 お父さんが勝手に言っているだけですから」\n",
"ムラサメ　CV：佐藤みかん\n神刀 “叢雨丸” に宿る魂のような存在。\n子供っぽい一面と、大人っぽい一面を併せ持っている。\n基本的には見た目通りの子供らしい性格で、元気で明るい女の子。\n数百年に渡り存在しているが、普通の人間には姿を見ることもできない。\n\n実は怖がりで、幽霊などが苦手。\n「吾輩の名はムラサメ。 この“叢雨丸”の管理者であり、神力（しんりき）を司る者である」",
"常陸 茉子 （ひたち まこ）　CV：小鳥居夕花\n巫女姫様の護衛として育てられた少女。\n仕事にはまじめだが、性格まで生真面目というわけではない。\nよく茶化したり イタズラを仕掛けたりと、お茶目な性格をしている。\n\n恥ずかしがり屋な一面もあり、女の子として褒められることが苦手。\n「そんなに美味しそうに食べてもらえると、紹介した私としても嬉しいです」",
"レナ・リヒテナウアー　CV：沢澤砂羽\n外国からやってきた留学生の女の子。\n明るく素直で優しく、いつも元気。 良くも悪くも真っ直ぐな性格。\nつまづいてもへこたれず、「挫けずに頑張りマスっ！」 と、一人で立ち直るタイプ。\n裏表がなく、純粋な幼子がそのまま成長したようなストレートな女の子\n\n優しい日本人が好き。 ニッポンも好き。\n「家でお母さんが日本の料理を調べて作ることもありましたので、お箸も慣れたものでありますよ」",
"請點選上方畫面上的圖片\n或是使用下拉式選單選取圖片"
];
var infoText;

class NewLamp {
  constructor(size, color, lightColor, lightPow) {
    this.box = new THREE.Mesh(new THREE.BoxGeometry(1 * size, 1 * size, 1 * size), new THREE.MeshPhongMaterial({
      color: color
    }));

    var tower = new THREE.Mesh(new THREE.CylinderGeometry(2 * size, 4 * size, 10 * size, 32, false, 0), new THREE.MeshPhongMaterial({
      color: color,
      side: THREE.DoubleSide
    }));
    this.box.add(tower);
    tower.castShadow = true; //default is false
    tower.receiveShadow = true; //default
    tower.position.y = -5 * size;

    var top = new THREE.Mesh(new THREE.CylinderGeometry(2 * size, 2 * size, 1 * size, 32), new THREE.MeshPhongMaterial({
      color: color,
      side: THREE.DoubleSide
    }));
    top.castShadow = true; //default is false
    top.receiveShadow = false; //default
    this.box.add(top);

    var bulb = new THREE.Mesh(new THREE.SphereGeometry(1 * size, 32, 32), new THREE.MeshPhongMaterial({
      color: 0x555555,
      opacity: 0.3,
      transparent: true,
      side: THREE.DoubleSide
    }));
    this.box.add(bulb);
    bulb.position.y = -2 * size;

    this.light = new THREE.PointLight(lightColor, lightPow, 0, 2);
    this.light.castShadow = true;
    this.box.add(this.light);
    this.light.position.y = -2 * size;

    scene.add(this.box);
  }
}

$("#defaultCam").click(function() {
	counter = 0;
	camera = cameras[counter];
	var informationText;
	informationText = $("#pictureInfo").text(pictureInfos[pictureInfos.length-1]);
	informationText.html(informationText.html().replace(/\n/g,'<br/>'));
	document.getElementById("selectArt").selectedIndex = 0;
});

/*$("#switchCam").click(function() {
  counter++;
  if (counter >= cameras.length)
    counter = 0;
  camera = cameras[counter];
});*/

$("#selectArt").change(function(){
  var informationText;
  if( $("#selectArt").val() == 0) {
	camera = cameras[0];
	informationText = $("#pictureInfo").text(pictureInfos[pictureInfos.length-1]);
	informationText.html(informationText.html().replace(/\n/g,'<br/>'));
  }
  else if( $("#selectArt").val() == 1) {
	camera = camerasOfPic[0];
	informationText = $("#pictureInfo").text(pictureInfos[0]);
	informationText.html(informationText.html().replace(/\n/g,'<br/>'));
  }
  else if( $("#selectArt").val() == 2) {
	camera = camerasOfPic[1];
	informationText = $("#pictureInfo").text(pictureInfos[1]);
	informationText.html(informationText.html().replace(/\n/g,'<br/>'));
  }
  else if( $("#selectArt").val() == 3) {
	camera = camerasOfPic[2];
	informationText = $("#pictureInfo").text(pictureInfos[2]);
	informationText.html(informationText.html().replace(/\n/g,'<br/>'));
  }
  else if( $("#selectArt").val() == 4) {
	camera = camerasOfPic[3];
	informationText = $("#pictureInfo").text(pictureInfos[3]);
	informationText.html(informationText.html().replace(/\n/g,'<br/>'));
  }
});

class NewCamera {
  constructor() {
    this.sCam = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
    //cameras.push(sCam);

    this.cameraObj = new THREE.Object3D();
    //this.cameraObj.add(new THREE.AxisHelper(40))
    this.cameraBody = new THREE.Mesh(new THREE.BoxGeometry(5 * ruler, 5 * ruler, 10 * ruler), new THREE.MeshPhongMaterial({
      color: 0x555555
    }));
    this.cameraBody.castShadow = true; //default is false
    this.cameraBody.receiveShadow = true; //default
    this.lens = new THREE.Mesh(new THREE.CylinderGeometry(2.5 * ruler, 3 * ruler, 3 * ruler, 32, false, 0), new THREE.MeshPhongMaterial({
      color: 0x555555
    }));
    this.lens.castShadow = true; //default is false
    this.lens.receiveShadow = true; //default
    this.lens.position.z = -6 * ruler;
    this.lens.rotation.x = Math.PI / 2;
    this.cameraObj.add(this.cameraBody, this.lens);

    this.cameraCase = new THREE.Object3D();
    this.cameraCase.add(this.cameraObj);
    this.cameraCase.position.set(50 * ruler, 75 * ruler, 50 * ruler);
    scene.add(this.cameraCase);
    //camCase.push(this.cameraCase);

    // manual aiming, from (-50,40,50) to (0,0,0)
    this.cameraCase.rotation.y = 0;
    this.cameraCase.rotation.x = 0;
    this.cameraCase.rotation.z = 0;
    this.cameraCase.rotation.order = 'YXZ'
  }
}

/*$('#butPower').click(function() {
  butPower = !butPower;

  if (butYL == true && butPower == true) {
    yardLight.forEach(function(l) {
      l.intensity = YLBrightness;
    })
  } else {
    yardLight.forEach(function(l) {
      l.intensity = 0;
    })
  }

  if (butLamp == true && butPower == true) {
    lamp.forEach(function(l) {
      l.light.intensity = lampBrightness;
    })
  } else {
    lamp.forEach(function(l) {
      l.light.intensity = 0;
    })
  }
});

$('#butYL').click(function() {
  butYL = !butYL;

  if (butYL == true && butPower == true) {
    yardLight.forEach(function(l) {
      l.intensity = YLBrightness;
    })
  } else {
    yardLight.forEach(function(l) {
      l.intensity = 0;
    })
  }
});

$('#YLBrightness').change(function() {
  YLBrightness = $(this).val();
  if (butYL == true && butPower == true)
    yardLight.forEach(function(l) {
      l.intensity = YLBrightness;
    })
	console.log(YLBrightness);
});

$('#butLamp').click(function() {
  butLamp = !butLamp;

  if (butLamp == true && butPower == true) {
    lamp.forEach(function(l) {
      l.light.intensity = lampBrightness;
    })
  } else {
    lamp.forEach(function(l) {
      l.light.intensity = 0;
    })
  }
});

$('#lampBrightness').change(function() {
  lampBrightness = $(this).val();
  if (butLamp == true && butPower == true)
    lamp.forEach(function(l) {
      l.light.intensity = lampBrightness;
    })
	console.log(lampBrightness);
});*/

var changeCam = 1;

$('#sCam1').click(function() {
	changeCam = 1;
});

$('#sCam2').click(function() {
	changeCam = 2;
});

$('#sCam3').click(function() {
	changeCam = 3;
});


init();
animate();

function init() {

  renderer = new THREE.WebGLRenderer({
    antialias: true
  });
  var ww = $('#container').innerWidth();
  var hh = $('#container').innerHeight();
  renderer.setSize(ww, hh);
  renderer.setClearColor(0x888888);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap
  $('#container').append(renderer.domElement);

  renderer2 = new THREE.WebGLRenderer({
    antialias: true
  });
  var ww2 = $('#container2').innerWidth();
  var hh2 = $('#container2').innerHeight();
  renderer2.setSize(ww2, hh2);
  renderer2.setClearColor(0x888888);
  renderer2.shadowMap.enabled = true;
  renderer2.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap
  $('#container2').append(renderer2.domElement);

  renderer3 = new THREE.WebGLRenderer({
    antialias: true
  });
  var ww3 = $('#container3').innerWidth();
  var hh3 = $('#container3').innerHeight();
  renderer3.setSize(ww3, hh3);
  renderer3.setClearColor(0x888888);
  renderer3.shadowMap.enabled = true;
  renderer3.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap
  $('#container3').append(renderer3.domElement);
  
  renderer4 = new THREE.WebGLRenderer({
    antialias: true
  });
  var ww4 = $('#container4').innerWidth();
  var hh4 = $('#container4').innerHeight();
  renderer4.setSize(ww4, hh4);
  renderer4.setClearColor(0x888888);
  renderer4.shadowMap.enabled = true;
  renderer4.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap
  $('#container4').append(renderer4.domElement);
  
  renderering = new THREE.WebGLRenderer({
    antialias: true
  });
  var ww5 = $('#sCamContainer').innerWidth();
  var hh5 = $('#sCamContainer').innerHeight();
  renderering.setSize(ww5, hh5);
  renderering.setClearColor(0x888888);
  renderering.shadowMap.enabled = true;
  renderering.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap
  $('#sCamContainer').append(renderering.domElement);

  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(50, $('#container').innerWidth() / $('#container').innerHeight(), 1, 1000);
  camera.position.y = 2000 * ruler;
  cameras.push(camera);
  camCase.push(null);
  angles.push(null);
  anglesCheck.push(null)
  signs.push(1);

  controls = new THREE.OrbitControls(camera, renderer.domElement);

  //////myScene//////
  //ambientlight
  var ambientLight = new THREE.AmbientLight(0xffffff, 0.5); // soft white light
  scene.add(ambientLight);

  let loader = new THREE.TextureLoader();
  loader.crossOrigin = '';
  texture = loader.load('img/tcP774R.jpg');
  texture.repeat.set(5, 5);
  texture.wrapS = texture.wrapT = true;

  var floor = new THREE.Mesh(new THREE.PlaneGeometry(1500 * ruler, 1500 * ruler), new THREE.MeshPhongMaterial({
    map: texture,
    side: THREE.DoubleSide
  }));
  floor.rotateX(Math.PI / 2);
  shadow(floor, false, true);
  floor.position.y = -0.05;
  scene.add(floor);
  floor.castShadow = true; //default is false
  floor.receiveShadow = true; //default

  var ceiling = new THREE.Mesh(new THREE.BoxGeometry(1540 * ruler, 50 * ruler, 1540 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff,
    opacity: 0.3,
    transparent: true,
    side: THREE.DoubleSide
  }));
  ceiling.position.y = 325 * ruler;
  scene.add(ceiling);
  ceiling.castShadow = true; //default is false
  ceiling.receiveShadow = true; //default

  var wall;
  wall = new THREE.Mesh(new THREE.BoxGeometry(1540 * ruler, 300 * ruler, 20 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  wall.position.set(0, 300 / 2 * ruler, (-(1500 + 20) / 2) * ruler);
  shadow(wall, false, true);
  scene.add(wall);

  wall = new THREE.Mesh(new THREE.BoxGeometry(20 * ruler, 300 * ruler, 1540 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  wall.position.set((-(1500 + 20) / 2) * ruler, 300 / 2 * ruler, 0);
  shadow(wall, false, true);
  scene.add(wall);

  wall = new THREE.Mesh(new THREE.BoxGeometry(20 * ruler, 300 * ruler, 1540 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  wall.position.set(((1500 + 20) / 2) * ruler, 300 / 2 * ruler, 0);
  shadow(wall, false, true);
  scene.add(wall);

  wall = new THREE.Mesh(new THREE.BoxGeometry(600 * ruler, 300 * ruler, 20 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  wall.position.set((-(1500 - 600) / 2) * ruler, 300 / 2 * ruler, ((1500 + 20) / 2) * ruler);
  shadow(wall, false, true);
  scene.add(wall);

  wall = new THREE.Mesh(new THREE.BoxGeometry(600 * ruler, 300 * ruler, 20 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  wall.position.set(((1500 - 600) / 2) * ruler, 300 / 2 * ruler, ((1500 + 20) / 2) * ruler);
  shadow(wall, false, true);
  scene.add(wall);

  wall = new THREE.Mesh(new THREE.BoxGeometry(20 * ruler, 300 * ruler, 300 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  wall.position.set((300 + 20) / 2 * ruler, 300 / 2 * ruler, ((1500 - 300) / 2) * ruler);
  shadow(wall, true, true);
  scene.add(wall);

  wall = new THREE.Mesh(new THREE.BoxGeometry(20 * ruler, 300 * ruler, 200 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  wall.position.set((-(300 + 20) / 2) * ruler, 300 / 2 * ruler, ((1500 - 200) / 2) * ruler);
  shadow(wall, true, true);
  scene.add(wall);

  var innerWall;
  innerWall = new THREE.Mesh(new THREE.BoxGeometry(20 * ruler, 300 * ruler, 220 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  innerWall.position.set(-((300 + 20) / 2 + 200) * ruler, 300 / 2 * ruler, (((1500 - 220) / 2) - 200) * ruler);
  shadow(innerWall, true, true);
  scene.add(innerWall);

  innerWall = new THREE.Mesh(new THREE.BoxGeometry(20 * ruler, 300 * ruler, 300 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  innerWall.position.set(290 * ruler, 300 / 2 * ruler, (((1500 - 320) / 2) - 110) * ruler);
  shadow(innerWall, true, true);
  scene.add(innerWall);

  innerWall = new THREE.Mesh(new THREE.BoxGeometry(640 * ruler, 300 * ruler, 20 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  innerWall.position.set(-30 * ruler, 300 / 2 * ruler, (((1500 + 20) / 2) - 420) * ruler);
  shadow(innerWall, true, true);
  scene.add(innerWall);

  innerWall = new THREE.Mesh(new THREE.BoxGeometry(60 * ruler, 300 * ruler, 300 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  innerWall.position.set(520 * ruler, 300 / 2 * ruler, (((1500 - 320) / 2) - 110) * ruler);
  shadow(innerWall, true, true);
  scene.add(innerWall);

  innerWall = new THREE.Mesh(new THREE.BoxGeometry(60 * ruler, 300 * ruler, 700 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  innerWall.position.set(520 * ruler, 300 / 2 * ruler, (480 - 150 - 100 - 350) * ruler);
  shadow(innerWall, true, true);
  scene.add(innerWall);

  innerWall = new THREE.Mesh(new THREE.BoxGeometry(60 * ruler, 300 * ruler, 480 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  innerWall.position.set(270 * ruler, 300 / 2 * ruler, (480 - 150 - 240) * ruler);
  shadow(innerWall, true, true);
  scene.add(innerWall);

  innerWall = new THREE.Mesh(new THREE.BoxGeometry(60 * ruler, 300 * ruler, 400 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  innerWall.position.set(270 * ruler, 300 / 2 * ruler, -450 * ruler);
  shadow(innerWall, true, true);
  scene.add(innerWall);

  innerWall = new THREE.Mesh(new THREE.BoxGeometry(600 * ruler, 300 * ruler, 100 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  innerWall.position.set(-285 * ruler, 300 / 2 * ruler, 0 * ruler);
  shadow(innerWall, true, true);
  scene.add(innerWall);

  innerWall = new THREE.Mesh(new THREE.BoxGeometry(600 * ruler, 300 * ruler, 100 * ruler), new THREE.MeshPhongMaterial({
    color: 0xffffff
  }));
  innerWall.position.set(-285 * ruler, 300 / 2 * ruler, -400 * ruler);
  shadow(innerWall, true, true);
  scene.add(innerWall);

  //////lamps//////
  let lPower = 0.1;
  lamp.push(new NewLamp(2 * ruler, 0x999999, 0xffffff, lPower));
  lamp[0].box.rotateZ(-Math.PI / 180 * 70);
  lamp[0].box.position.set(-500 * ruler, 265 * ruler, 550 * ruler);

  lamp.push(new NewLamp(2 * ruler, 0x999999, 0xffffff, lPower));
  lamp[1].box.rotateZ(-Math.PI / 180 * 70);
  lamp[1].box.position.set(-500 * ruler, 265 * ruler, 175 * ruler);
  
  lamp.push(new NewLamp(2 * ruler, 0x999999, 0xffffff, lPower));
  lamp[2].box.rotateZ(-Math.PI / 180 * 70);
  lamp[2].box.position.set(-500 * ruler, 265 * ruler, -225 * ruler);

  lamp.push(new NewLamp(2 * ruler, 0x999999, 0xffffff, lPower));
  lamp[3].box.rotateZ(-Math.PI / 180 * 70);  
  lamp[3].box.position.set(-500 * ruler, 265 * ruler, -575 * ruler);

  //////yardLight//////
  let ylDistense = 750*ruler;
  let ylPower = 0.6;
  yardLight.push(new THREE.PointLight(0xffffff, ylPower, ylDistense, 2));
  yardLight[0].castShadow = true;
  yardLight[0].position.set(-500 * ruler, 295 * ruler, 550 * ruler);

  yardLight.push(new THREE.PointLight(0xffffff, ylPower, ylDistense, 2));
  yardLight[1].castShadow = true;
  yardLight[1].position.set(-500 * ruler, 295 * ruler, 250 * ruler);

  yardLight.push(new THREE.PointLight(0xffffff, ylPower, ylDistense, 2));
  yardLight[2].castShadow = true;
  yardLight[2].position.set(-500 * ruler, 295 * ruler, -190 * ruler);
  
  yardLight.push(new THREE.PointLight(0xffffff, ylPower, ylDistense, 2));
  yardLight[3].castShadow = true;
  yardLight[3].position.set(-500 * ruler, 295 * ruler, -580 * ruler);

  yardLight.forEach(function(yL, i) {
    scene.add(yL);
    pointLightHelper.push(new THREE.PointLightHelper(yL, 2));
    scene.add(pointLightHelper[i]);
  })

  //////cameras//////
  var myCamera;
  myCamera = new NewCamera();
  cameras.push(myCamera.sCam);
  camCase.push(myCamera.cameraCase);
  camCase[1].position.set(-725 * ruler, 275 * ruler, 725 * ruler);
  camCase[1].rotation.y = -Math.PI / 3;
  camCase[1].rotation.x = -Math.PI / 6;
  camCase[1].rotation.z = 0;
  angles.push(camCase[1].rotation.y);
  anglesCheck.push(camCase[1].rotation.y)
  signs.push(1);

  myCamera = new NewCamera();
  cameras.push(myCamera.sCam);
  camCase.push(myCamera.cameraCase);
  camCase[2].position.set(225 * ruler, 275 * ruler, 300 * ruler);
  camCase[2].rotation.y = Math.PI / 4;
  camCase[2].rotation.x = -Math.PI / 6;
  camCase[2].rotation.z = 0;
  angles.push(camCase[2].rotation.y);
  anglesCheck.push(camCase[2].rotation.y)
  signs.push(1);
  
  myCamera = new NewCamera();
  cameras.push(myCamera.sCam);
  camCase.push(myCamera.cameraCase);
  camCase[3].position.set(-700 * ruler, 275 * ruler, -700 * ruler);
  camCase[3].rotation.y = Math.PI/6*7;
  camCase[3].rotation.x = -Math.PI / 6;
  camCase[3].rotation.z = 0;
  angles.push(camCase[3].rotation.y);
  anglesCheck.push(camCase[3].rotation.y)
  signs.push(1);
  
  //pictures
  texture = loader.load('img/c895010chara1.jpg');
  texture.repeat.set(1, 1);
  texture.wrapS = texture.wrapT = true;
  var pic = new THREE.Mesh(new THREE.PlaneGeometry(200 * ruler, 240 * ruler), new THREE.MeshPhongMaterial({
    map: texture,
    side: THREE.DoubleSide
  }));
  shadow(floor, false, true);
  pic.rotation.y = Math.PI/2;
  //pic.castShadow = true; //default is false
  pic.receiveShadow = true; //default
  pic.name = "朝武 芳乃";
  pickables.push (pic);
  pickables[0].position.set(-745 * ruler, 140 * ruler, 550 * ruler);//lamp[0].box.position.set(-500 * ruler, 265 * ruler, 475 * ruler);
  scene.add(pickables[0]);
  cameraOfPic = new THREE.PerspectiveCamera(50, $('#container').innerWidth() / $('#container').innerHeight(), 1, 1000);
  cameraOfPic.position.set(-450 * ruler, 150 * ruler, 550 * ruler);
  cameraOfPic.lookAt(new THREE.Vector3(-745 * ruler, 140 * ruler, 550 * ruler));
  camerasOfPic.push(cameraOfPic);
  
  texture = loader.load('img/c895010chara3.jpg');
  texture.repeat.set(1, 1);
  texture.wrapS = texture.wrapT = true;
  pic = new THREE.Mesh(new THREE.PlaneGeometry(200 * ruler, 240 * ruler), new THREE.MeshPhongMaterial({
    map: texture,
    side: THREE.DoubleSide
  }));
  shadow(floor, false, true);
  pic.rotation.y = Math.PI/2;
  //pic.castShadow = true; //default is false
  pic.receiveShadow = true; //default
  pic.name = "ムラサメ";
  pickables.push (pic);
  pickables[1].position.set(-745 * ruler, 140 * ruler, 175 * ruler);//lamp[1].box.position.set(-500 * ruler, 265 * ruler, 175 * ruler);
  scene.add(pickables[1]);
  cameraOfPic = new THREE.PerspectiveCamera(50, $('#container').innerWidth() / $('#container').innerHeight(), 1, 1000);
  cameraOfPic.position.set(-450 * ruler, 150 * ruler, 175 * ruler);
  cameraOfPic.lookAt(new THREE.Vector3(-745 * ruler, 140 * ruler, 175 * ruler));
  camerasOfPic.push(cameraOfPic);
  
  texture = loader.load('img/c895010chara2.jpg');
  texture.repeat.set(1, 1);
  texture.wrapS = texture.wrapT = true;
  pic = new THREE.Mesh(new THREE.PlaneGeometry(200 * ruler, 240 * ruler), new THREE.MeshPhongMaterial({
    map: texture,
    side: THREE.DoubleSide
  }));
  shadow(floor, false, true);
  pic.rotation.y = Math.PI/2;
  //pic.castShadow = true; //default is false
  pic.receiveShadow = true; //default
  pic.name = "常陸 茉子";
  pickables.push (pic);
  pickables[2].position.set(-745 * ruler, 140 * ruler, -225 * ruler);//lamp[2].box.position.set(-500 * ruler, 265 * ruler, -225 * ruler);
  scene.add(pickables[2]);
  cameraOfPic = new THREE.PerspectiveCamera(50, $('#container').innerWidth() / $('#container').innerHeight(), 1, 1000);
  cameraOfPic.position.set(-450 * ruler, 150 * ruler, -225 * ruler);
  cameraOfPic.lookAt(new THREE.Vector3(-745 * ruler, 140 * ruler, -225 * ruler));
  camerasOfPic.push(cameraOfPic);
  
  texture = loader.load('img/c895010chara4.jpg');
  texture.repeat.set(1, 1);
  texture.wrapS = texture.wrapT = true;
  pic = new THREE.Mesh(new THREE.PlaneGeometry(200 * ruler, 240 * ruler), new THREE.MeshPhongMaterial({
    map: texture,
    side: THREE.DoubleSide
  }));
  shadow(floor, false, true);
  pic.rotation.y = Math.PI/2;
  //pic.castShadow = true; //default is false
  pic.receiveShadow = true; //default
  pic.name = "レナ・リヒテナウアー";
  pickables.push (pic);
  pickables[3].position.set(-745 * ruler, 140 * ruler, -575 * ruler);//lamp[3].box.position.set(-500 * ruler, 265 * ruler, -575 * ruler);
  scene.add(pickables[3]);
  cameraOfPic = new THREE.PerspectiveCamera(50, $('#container').innerWidth() / $('#container').innerHeight(), 1, 1000);
  cameraOfPic.position.set(-450 * ruler, 150 * ruler, -575 * ruler);
  cameraOfPic.lookAt(new THREE.Vector3(-745 * ruler, 140 * ruler, -575 * ruler));
  camerasOfPic.push(cameraOfPic);
  

  window.addEventListener('resize', onWindowResize, false);
  window.addEventListener('mousedown', onDocumentMouseDown, false);
  
  //$("#selectArt").option = 2;

}

function onWindowResize() {
  var ww = $('#container').innerWidth();
  var hh = $('#container').innerHeight();
  camera.aspect = ww / hh;
  camera.updateProjectionMatrix();
  renderer.setSize(ww, hh);

  var ww2 = $('#container2').innerWidth();
  var hh2 = $('#container2').innerHeight();
  camera2.aspect = ww2 / hh2;
  camera2.updateProjectionMatrix();
  renderer2.setSize(ww2, hh2);

  var ww3 = $('#container3').innerWidth();
  var hh3 = $('#container3').innerHeight();
  camera3.aspect = ww3 / hh3;
  camera3.updateProjectionMatrix();
  renderer3.setSize(ww3, hh3);
  
  var ww4 = $('#container4').innerWidth();
  var hh4 = $('#container4').innerHeight();
  camera4.aspect = ww4 / hh4;
  camera4.updateProjectionMatrix();
  renderer4.setSize(ww4, hh4);
  
  var ww5 = $('#sCamContainer').innerWidth();
  var hh5 = $('#sCamContainer').innerHeight();
  sCamera.aspect = ww5 / hh5;
  sCamera.updateProjectionMatrix();
  renderering.setSize(ww5, hh5);
}

function onDocumentMouseDown(event) {

  //event.preventDefault();

  // many unsuccessful tries ...
  /*
    mouse.x = ((event.clientX - event.target.offsetLeft) / $('#container').innerWidth()) * 2 - 1;
    mouse.y = -((event.clientY - event.target.offsetTop) / $('#container').innerHeight()) * 2 + 1;
  */

  var viewportPos = $('#container').get(0).getBoundingClientRect();
  mouse.x = ((event.clientX - viewportPos.left) / $('#container').innerWidth()) * 2 - 1;
  mouse.y = -((event.clientY - viewportPos.top) / $('#container').innerHeight()) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);
  var intersects = raycaster.intersectObjects(pickables);
  if (intersects.length > 0) {
    //cyl.position.copy(intersects[0].point);
    //alert(intersects[0].object.name + " is picked!");
	for(var cc = 0; cc < pickables.length; cc++){
		if(camera == cameras[0])
			if(intersects[0].object.name == pickables[cc].name){
				camera = camerasOfPic[cc];
				//infoText = $("#pictureInfos[cc]");
				//infoText.html(pictureInfo.html().replace(/\n/g,'<br/>'));
				//$("#pictureInfo").text(infoText);
				
				informationText = $("#pictureInfo").text(pictureInfos[cc]);
				informationText.html(informationText.html().replace(/\n/g,'<br/>'));
				document.getElementById("selectArt").selectedIndex = cc+1;
			}
	}
  }
}

function animate() {
  requestAnimationFrame(animate);
  render();
}

function render() {

  for (let cc = 0; cc < angles.length; cc++) {
    if (angles[cc] != null && anglesCheck[cc] != null) {
      angles[cc] += 0.004 * signs[cc];
      if (angles[cc] > anglesCheck[cc] + 0.5 || angles[cc] < anglesCheck[cc] - 0.5)
        signs[cc] *= -1;
      if (camCase[cc] != null)
        camCase[cc].rotation.y = angles[cc];
    }
  }

  for (let cc = 0; cc < camCase.length; cc++) {
    if (camCase[cc] != null) {
      cameras[cc].matrixWorld.copy(camCase[cc].matrixWorld);
      cameras[cc].matrixAutoUpdate = false;
    }
  }

  renderer.render(scene, camera);

  camera2 = cameras[1];
  renderer2.render(scene, camera2);
  camera3 = cameras[2];
  renderer3.render(scene, camera3);
  camera4 = cameras[3];
  renderer4.render(scene, camera4);
  
  sCamera = cameras[changeCam];
  
  renderering.render(scene, sCamera);
}

function shadow(Object, castShadow, receiveShadow) {
  Object.castShadow = castShadow;
  Object.receiveShadow = receiveShadow;
}


</script>

</body>
</html>


